
# Множественное наследование. Так ли страшен чёрт?

## Предисловие

Наследование - это понятие из ООП, определяющее отношение между классами. Когда один класс наследует другой, он расширяет его функциональность. Объекты производного класса одновременно принадлежат и базовому классу. Для классов из ООП можно провести аналогию с множествами. Объекты - это абстрактные сущности для моделирования чего-либо из реального мира. Все объекты можно поделить на множества, называемые классами. Для множеств есть операции объединения и пересечения. Почему этого не может быть и с классами?

Сам по себе класс - это ещё одна абстрактная сущность, обозначающая набор признаков, по которым можно выделить множество объектов этого класса.

Отношение наследования между двумя классами означает, что объект производного класса одновременно принадлежит множеству объектов базового класса. Если базовых классов будет несколько, то множество объектов производного класса является пересечением множеств объектов базовых классов.

Всё прекрасно в теории, когда стоит лишь задача моделирования. Но есть проблемы с реализацией множественного наследования в программах.

### Компромис дизайна языков программирования

Что есть объект в программе? Это всё ещё абстрактная сущность, которая как-то представлена в оперативной памяти, и это представление как-то связано с фрагментами исполняемого кода, которые отвечают за поведение этого класса. Иными словами, в программе подразумевается некоторая структура данных в памяти, которая является обозначением того объекта, который мы подразумеваем в процессе моделирования в терминах языка программирования. Способы представления объектов, классов и всех отношений между ними могут быть разные, и дизайнеры языков стремятся, чтобы это представление было оптимальным и эффективным. И здесть есть компромис.

Есть три полюса, между которыми приходится балансировать:

* Вычислительная среда
* Математические абстракции
* Человеческое мышление

Программы в любом случае будут исполняться на некоторой вычислительной машине, которая имеет свои особенности. Например, что представления объектов придётся располагать в памяти с линейной адресацией, а значит, распределением этой памяти надо управлять. Процессор работает в соответствии со своей архитектурой набора команд. Сами по себе объекты могут быть представлены разными структурами данных, эффективные для этого конкретного типа вычислительной машины.

В основе дизайна языков программирования лежит много математики. В идеале, хочется представить программу в разрезе математики и использовать наиболее удобный для рассуждений математический аппарат, включая синтаксис.

В то же время, программы на высокоуровневых языках пишут люди, решая свои задачи в терминах этих задач через призму своей человеческой культуры (языка, понятий, аналогий, паттернов).

### Абстрактный пример множественного наследования

// TODO: Придумать


## Множественное наследование в разных языках

### C++

Это один из первых языков, в котором начали проявляться проблемы множественного наследования. В С++ виды наследования бывают самые разные (private, protected, public, virtual). У каждого базового класса указывается модификатор доступа. Наследование напоминает композици. Отличие в том, что все члены базовых классов доступны напрямую в производном классе. Возможно повторное наследование одного и того же класса. Один и тот же класс может встречаться несколько раз выше по графу наследования. В этих случаях на каждый такой случай наследования в объекте будет свой отдельный подобъект базового класса.

В С++ состояние объекта представлено областью смежных байт в памяти известного размера. Для каждого типа компилятор знает размер структуры в байтах. Объекты могут быть подобъектами других объектов. При композиции последовательность байт подобъекта просто включается в последовательность байт другого объекта и является его непосредственной частью. Объекты базовых классов являются такими же подобъектами объектов производного класса, как и при композиции.

#### В C++ нет интерфейсов!

В C++ каждый класс является типом данных и не является подтипом никакого другого типа. А вот тип указателя на объекты этого класса является подтипом типа указателя на любой из базовых классов выше по графу наследования.

В C++ публичный интерфейс класса никак не представлен отдельной сущностью в системе типов. Нет такого отдельного понятия, как "интерфейс". Абстрактные классы с чисто виртуальными методами - это тоже классы. Они часто используются в наследовании как интерфейсы.

Граф наследования в C++ является ориентированным ациклическим графом. В нём могут возникать "ромбы".

#### Проблема "ромба" (Diamond problem)

Проблемой является возможные конфликты имён и не только.

Члены разных базовых классов могут быть названы одинаково. В C++ есть способы разрешения этих конфликтов путём явного указания базового класса при обращении к члену. Но не все случаи возможно решить. Если один и тот же класс встречается несколько раз среди базовых, то не понятно в какому из подобъектов происходит обращение. При обращении к членам транзитивно наследуемого класса может быть несколько путей достижения его по графу наследования.

Также, при приведении объекта к типу базового класса не ясно, указатель на какой из подобъектов имеется ввиду, если наследование повторное.

Что делать с этими проблемами? Всё просто. Если компилятор где-то заметит потенциальную неоднозначность, то это ошибка компиляции. Чаще всего такой код на практике встречаться не будет.

#### Виртуальное наследование

Виртуальное наследование - частичное решение проблемы "ромба". Если виртуальный базовый класс несколько раз встречается в графе наследования производного класса, то его подобъект будет представлен в одном экземпляре в объекте производного класса. Ценой тому будет лишний скрытый указатель в объекте и переходы по нему при обращении к членам этого базового класса.

Абстрактные классы с чисто виртуальными методами и без полей для хранения состояния часто играют роль интерфейсов в C++.

### Java

В Java всё просто: множественное наследование классов запрещено в языке изначально.

Сходство реализации наследования с С++ в том, что подобъект базового класса представлен в объекте производного класса так же, как и в C++. Конечно, это зависит от реализации JVM.

В Java разрешено множественное наследование интерфейсов, которое не имеет никаких проблем, потому что интерфейсы специально ограничены в своей функциональности. Даже в случае ромба есть чёткие правила, определяющие, какой метод будет вызван. С приведением типа к типу интерфейса тоже никаких проблем нет - всё однозначно, даже если интерфейс несколько раз встречается в графе наследования интерфейсов.

#### Проблемы запрета множественного наследования

Все объекты обязаны наследоваться от корневого класса иерархии наследования - класса Object. По идее, класс Object не должен содержать никакой специфичной функциональности, потому что ему должны принадлежать все вообще объекты. Получается все объекты получают неотключаемую функциональность: equals()/hashCode(), wait()/notify(), возможность быть мьютексом в synchronize - хотим мы того или нет.

Необходимость дублировать код той функциональности, которую нельзя включить в цепочку наследования класса, потому что роль базового класса уже занята. Можно, конечно, и в таком случае хорошо отрефакторить код и привести к лучшему виду. Но проявится другая крайность. Даже в книгах по паттернам проектирования встречается очень частое использование тривиальных "мостовых" методов, когда метод состоит только из одного вызова почти такого же по смыслу метода у какого-то другого объекта. Это часто происходит в случаях, когда наследование заменяется композицией. Именно это обычно и советуют как более приоритетное решение.

Однако, начиная с Java 8, ситуация начала меняться.

#### Методы с реализацией в интерфейсах

В Java 8 интерфейсы могут иметь методы с реализацией - default-методы. В Java 9 в интерфейсах было позволено иметь приватные методы с реализацией. В этом случае интерфейс содержит не просто публичный API, но и некоторую повторно используемую часть функциональности. Так как для интерфейсов разрешено множественное наследование, это позволяет выполнять сложную композицию функциональности без нагромождения всего в одном классе. Обязанности могут быть более гибко разделены между сущностями.

В некоторых случаях это позволяет избежать лишней композиции.

### C# 8

В C# 8 была добавлена точно такая же возможность включать реализацию методов в интерфейсы. Раньше интерфейсы в C# имели примерно те же правила, что и до Java 8.

### Scala

В Scala множественное наследование разрешено, но, опять же, не для обычных классов, а для специальных сущностей, похожих на интерфейсты - traits. Трейты могут иметь свои абстрактные методы, методы с реализацией, приватные методы с реализацией и даже поля с данными. Трейты могут наследовать друг друга. Когда множество трейтов используются в списке базовых классов, правила разрешения конфликтов имён членов чётко определено, в отличие от C++. Порядок наследования трейтов важен. Более поздний трейт может перекрывать члены предыдущих трейтов.

Каждый трейт имеет возможность узнать что-то о том, к какому классу его присоединили. Например, трейт может выставить требования, что его можно присоединять не ко всем подряд классам, а лишь к тем, которые реализуют ещё какие-то трейты. Таким образом, трейты могут декларировать зависимости между собой, проверяемые компилятором.

### Python

### JavaScript

## Наследование и композиция

### Кусок класса - mixin

### Типы. Система типов

### Наследование интерфейсов

### Композиция реализаций
