WIP

# Введение

## Процесс разработки программ и обеспечение корректности

Процесс разработки программного обеспечения состоит из нескольких фаз: анализ и постановка задачи, проектирование, реализация и тестирование. Разработчик после фазы анализа получает в качестве исходных данных для разработки __модель__ решаемой задачи. Эта модель может быть как выражена в виде артефактов анализа, так и просто представляться в голове у разработчика. _Язык описания_ модели может быть как строгим и формальным, так и естественным. Различные артефакты анализа - описание требований, ограничений, зависимостей - могут быть выражены на формальном языке. Остальные требования могут иметь поверхностное и неточное описание, передаваться только устно или подразумеваться по-умолчанию. Важно, чтобы разработчик хорошо понимал модель задачи и представлял её для себя наиболее полно.

Модель состоит из словаря _понятий_ предметной области, описаний _объектов_, входящих в неё, описание их _структуры_ и _связей_ между ними, а также, из _утверждений_ и _ограничений_, которые должны быть удовлетворены в ходе реализации модели. Далее, по мере написания программы разработчики оперируют только с этой моделью и выстраивают на её основе части программной системы. Результатом реализации модели будет __код__ на строгом, _формальном языке_, который может быть интерпретирован однозначно некоторой средой исполнения.

Что представляет собой программный код? Он определяет требуемое поведение вычислительной машины в рамках задачи. Вычислительная машина - это __среда исполнения__ программного кода, которая тоже имеет свою модель, структуру и ограничения. И эта модель учитывается при проработке модели поставленной задачи. В модели вычислительной среды могут учитываться такие вещи как API операционной системы, исполнение команд процессором, поведение интерпретатора скриптов или байткода, управление памятью, работа с диском и другие. Все эти части вычислительной системы тоже имеют свои _слои абстракции_, гарантирующие определённое поведение. Разработчик увязывает модель вычислительной системы с моделью задачи путём написания программного кода, заставляя вычислительную систему действовать согласно требованиям задачи.

Когда некоторые фрагменты программы уже написаны, возникает проблема обеспечения _соответствия_ поведения получившейся программной системы требованиям поставленной задачи. Эта широкая проблема может включать в себя ряд более узких вопросов, возникающих по ходу написания отдельных фрагментов кода. Часть вопросов касается только вычислительной среды и не зависит от поставленной задачи, другая часть вопросов состоит именно в проверке требований задачи. Программа считается __корректной__, когда выполнены все требования и программа ведёт себя в соответствии с _ожиданиями_, подразумевающимися в модели.

Не всегда можно __доказать__ корректность программы. Это возможно, вероятно, только для самых примитивных программ, решающих самые примитивные задачи. Поэтому чаще всего задача _строгого_ обеспечения корректности на практике не ставится. К тому же, не всегда бывают полностью и строго описаны требования. Поэтому команды разработки обычно полагаются на _тестирование_, проверяя отдельные аспекты корректности программы эмпирически.

Многие относительно простые вопросы, возникающие в ходе написания кода, можно и нужно решать. Эти вопросы могут решаться как вручную программистами с привлечением их собственного ума для рассуждений, так и автоматическими инструментами. Оба метода будут использовать сведения из моделей задачи и среды исполнения. Чем формальнее и строже определены эти модели, тем проще использовать автоматизированные средства.

## Вопросы, решаемые в ходе написание кода

Какие же вопросы задаёт себе программист, когда пишет программный код? Вот несколько примеров:

* "Упадёт" ли программа на определённых входных данных с ошибкой?
* Зациклится ли программа? Завершится ли она когда-нибудь?
* Возможен ли stack overflow? При каких условиях?
* Какие возможные значения может принять та или иная переменная?
* Будет ли изменяться значение некоторого выражения при прохождении итераций цикла?
* Содержит ли данная функция побочные эффекты, влияющие на исполнение других частей программы и на саму среду исполнения?
* Где в программе потенциальные места утечек памяти?
* Будет ли выброшено исключение? И если да, то будет ли оно перехвачено в определённой точке программы?
* Дойдёт ли исполнение программы когда-нибудь до определённого места в коде при определённых условиях?
* Нет ли в коде определённого рода ошибок, не нарушаются ли где-то предполагаемые ограничения на значения?

И многие другие.

Мелкие вопросы могут складываться в более сложные. Сам по себе язык программирования имеет минимальный набор встроенных в себя простых понятий, а программист мыслит более сложными конструкциями - паттернами. Поэтому и вопросы о программах могут быть выражены и на языке паттернов, и на языке предметной области. Например:

* Исполняет ли данный класс в программе определённую роль? Не возложены ли на него какие-то другие обязанности?
* Какие паттерны использованы в программе? В каких паттернах участвует тот или иной класс?
* Являются ли два фрагмента кода дублирующими друг друга, эквивалентными с точки срения реализованной функциональности?
* Ведёт ли себя функция так, как задумывалось в требованиях?

Отдельно можно упомянуть о вопросах, касающихся производительности: как производительности работы программы (затраты времени и памяти), так и производительности труда программиста по написанию, рефакторингу и отладке возможных ошибок. Например, в динамически типизированных языках рефакторинг затруднён, и при простом желании переименовать некоторую сущность в программе (например, property в объектах) возникает вопрос, эквивалентное ли это преобразование, не затронуло ли оно чего-то в системе, корректно ли были переименованы все упоминания данной сущности. Типичные примеры вопросов о производительности программы следующие.

* Какова зависимость времени исполнения, использования памяти или глубины стека от различных параметров входных данных?
* Какова сложность алгоритма по времени выполнения и использованию памяти?
* Каков "лучший" и "худший" возможные случаи исполнения программы?
* Сколько потраченных ресурсов являются накладными расходами (overhead)?

Вопросы производительности в меньшей степени относятся к проблеме корректности. Требования оптимизации не всегда являются обязательными для выполнения, но рекомендуемыми. Тем не менее, все перечисленные вопросы и многие другие имеют прямое отношение к вопросу корректности программы и требуют для своего решения специальных методов рассуждений.

## А зачем всё это надо?

Цель данной статьи - показать, что серьёзная разработка больших сложных программ представляет собой не какой-то стихийный творческий процесс, а управляемый требованиями целенаправленный процесс, в котором за ошибки придётся расплачиваться, в связи с чем стоит серьёзно подойти к их минимизации. Программист, на самом деле, во многом математик, оперирующий математическими моделями, и он может прибегать к необходимости строгих математических доказательств, чтобы полностью быть уверенным в некоторых аспектах поведения программы и не бояться работать над ней дальше. Программный код - это своего рода формула, которую программист дописывает и преобразовывает согласно строгим математическим правилам. И только при соблюдении всех необходимых правил эта формула будет корректно интерпретирована вычислительной средой. Современные языки программирования вобрали в себя очень много математических концепций, знание которых полезно при использовании инструментов разработки и отладки, да и просто при проектировании.

> "Ну мы же не для ядерного реактора ПО пишем?"

Некоторые программы в коммерческой разработке берут на себя большую большую роль, и их разработчикам приходится брать на себя большую ответственность. И чтобы "спать спокойно", лучше облегчать себе разработку применением более надёжных инструментов и методов, а также, придерживаться определённых практик там, где автоматические средства не могут помочь.

Далее будут рассмотрены средства, помогающие отвечать на многие вопросы о программах. Подробнее будет рассмотрена именно теория типов как более простой в применении и распространённый на практике метод. Также будут перечислены средства автоматической проверки программ, использующих доказательства утверждений о программах и системы типов.

# Методы и средства рассуждений о программах

## Статический анализ

Программный код сам по себе содержит много информации о том, как будет происходить выполнение программы. Фактически, вся информация о программе в процессе её исполнения находится в её коде. Исходный код является _базой знаний_ для проведения рассуждений и доказательства утверждений. Эти утверждения можно сделать ещё до исполнения программы. Анализ поведения программы без её реального запуска по одному лишь исходному коду называется [статическим анализом](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BA%D0%BE%D0%B4%D0%B0). Ему противопоставляется динамический анализ, когда поведение программы анализируется в ходе её исполнения. В динамический анализ включаются отладка и профилирование.

Одним из преимуществ статического анализа является отсутствие жёстких требований на время анализа и используемые ресурсы. Также есть гарантия отсутствия рисков, которые могут возникнуть во время реального запуска. Если программа ошибочна или потенциально опасна для запуска, то при статическом анализе есть шанс узнать это ещё до её запуска, пока она не успела натворить чего-то необратимого (или труднообратимого). Например, программа в ходе выполнения

* может что-то модифицировать в базе данных
* или отправить какие-то данные в сеть,
* или это bash-скрипт, который может что-то удалить или напортить в файловой системе, если будет запущен от root,
* или может никогда не проявлять ничего странного и пройти этап тестирования, но при определённой "фазе луны" (сложившихся условиях, например, ситуации "гонок") рушить процесс с core dump или даже всю систему с kernel panic на боевом сервере.

Такие изменения очень сложно откатывать, поэтому экспериментальные запуски таких программ нежелательны. Тем не менее, развёртывание тестового окружения и отладка программ при исполнении может дать информацию, недоступную при статическом анализе. Ведь к недостаткам статического анализа можно отнести его _ограниченность_ в возможностях проанализировать достаточно _глубоко_ большие фрагменты сложного кода.

### Формальные системы и семантика программ

Крайним случаем использования статического анализа при проверке корректности программы является [формальная верификация](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F). При формальной верификации полностью доказывается корректность программы и исключается необходимость в тестировании. Можно быть полностью уверенным в правильности программы и сразу начать её внедрение. Однако, на практике не ко всем программам можно применить формальную верификацию, и разработчики обходятся более слабым статическим анализом.

Статический анализ применяется к программному коду, проверяя его в соответствии с определённой формальной моделью, зависящей от языка программирования. У каждого языка программирования есть свои _синтаксис_ и _семантика_. Систаксис всех языков задаётся примерно одинаково: выбирается алфавит и правила, определяющие, принадлежит ли данная строка кода языку. Правила могут быть заданы либо формальной грамматикой, либо автоматом с состояниями. Более сложным будет определить семантику языка - смысл программного кода, записанного на языке.

В чём смысл существования любого программного кода? В том, что он будет либо скомпилирован и исполнен в среде исполнения, либо сразу выполнен интерпретатором. Смысл кода может подразумевать все возможные случаи использования этого кода, но в первую очередь рассматривается обычное исполнение в определённой среде. Задача статического анализа состоит в том, чтобы работать с моделью этого исполнения и доказывать в рамках этой модели различные утверждения. Для описания таких моделей в математике 20 века появились различные формальные системы, берущие своё начало из оснований математики и теории алгоритмов.

[Формальная система](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0) - это, грубо говоря, некоторый символический язык со своими правилами, вносящими ограничения на конструкции языка, тем самым наделяя их различными свойствами. Существуют формализмы для описания работы вычислительных систем и подходы к определению семантики языка программирования. В зависимости от парадигмы программирования вводятся базовые понятия (например, ячейки памяти и адресация, или, например, функции, значения, операторы) и правила, описывающие эти абстракции.

Есть несколько подходов к определению [семантики](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D0%BA%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) языка. Среди них наиболее интересны следующие.

* Операционная семантика представляет собой описание абстрактной виртуальной машины, которая исполняет программный код. Каково будет поведениее этой виртуальной машины в результате интерпретации фрагмента кода, таков и будет его смысл. Эта семантика применяется чаще всего при описании языков программирования, потому что она простая в понимании и близка по своей сути к реальной реализации среды исполнения для этого языка.

* Денотационная семантика - это набор правил преобразования программного кода в абстрактные математические объекты, которые и обозначают смысл исполнения этого кода. Этот подход к описанию семантики более абстрактен и используется обычно в исследованиях.

Определение семантики языка позволяет проводить рассуждения над программным кодом формальными методами, которые возможно реализовать в автоматизированных инструментах.

### Сильные и ослабленные теории.

Если решать задачу определения корректности программы в общем случае, попытаться ответить на все вообще возможные вопросы о программе, то для этого понадобятся мощные теории, которые позволят проводить доказательства довольно сильных утверждений вплоть до полной формальной верификации. Есть теории, позволяющие получать все подробности возможных вариантов исполнения программы. Их можно условно назвать _сильными теориями_. В качестве примера можно привести [логику Хоара](https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0_%D0%A5%D0%BE%D0%B0%D1%80%D0%B0).

Логика Хоара - это формальная система для доказательства утверждений о последовательной (однопоточной) программе, представленной в виде последовательности операторов, меняющих значения переменных. Она хорошо ложится на императивную парадигму. В ней есть такие понятия как переменная, выражение и оператор. Для всех операторов определяются правила, описывающие, как изменятся значения переменных после выполнения оператора. Логика Хоара использует синтаксис "троек Хоара" в виде "Предусловие - Выражение программы - Постусловие". Предусловие - это высказывание, которое должно выполняться до исполнения фрагмента кода. Постусловие - это высказывание, которое обязательно будет истинным после выполнения фрагмента кода, если Предусловие было истинно. Элементарные правила рассуждений рассматриваются для всех элементарных операторов: присваивание, последовательное исполнение, ветвление, цикл. Используя эти правила можно строить рассуждения и доказывать различные утверждения о программе. Но сложность этих доказательств слишком велика, чтобы применять их на практике. К тому же известно, что задача доказательства некоторых утверждений алгоритмически неразрешима. Но некоторые более простые узкие задачи рассуждений легче поддаются решению, и для них были разработаны более простые теории. Эти теории не так универсальны, как логика Хоара, и позволяют доказывать более слабые утверждения, но и эти утверждения очень полезны при работе с программным кодом.

Например, утверждение о том, что значение некоторого выражения всегда будет принадлежать к определённому множеству (попадает под определённые ограничения), - более слабое утверждение, чем если бы было известно точное значение выражения. Подобные слабые утверждения могут быть доказаны с использованием специализированных ослабленных теорий. Одной из самых распространённых на практике является [теория типов](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2). Её суть состоит в том, что определяется система типов, согласно которой каждое вычисленное в программе значение можно отнести к тому или иному типу. Таким образом, каждому выражению в программе можно приписать определённый тип, который обозначает некоторое ограничение на возможные значения, которые может принять данное выражение. Утверждение, что некоторое выражение программы имеет определённый тип, является утверждением типизации. Именно с этими утверждениями и происходят рассуждения.

Для каждого языка программирования определяется своя [система типов](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2), которая приписывает каждому подвыражению определённый тип на основе правил типизации. Нарушением этих правил в программе будет ошибка согласования типов. Наличие таких ошибок говорит о возможных ошибках при исполнении программы. Отсутствие ошибок согласования типов гарантирует _типобезопасность_. Программа, в которой выполняется типобезопасность, избавлена от некоторого класса ошибок на этапе исполнения. Множество ошибок, охватываемых понятием типобезопасности, зависит от мощности системы типов в языке программирования. В одних языках система типов более строгая, чем в других. Например, в C++ более строгая и гибкая типизация, чем в C, в Kotlin более строгая система типов, чем в Java.

### Системы автоматического доказательства теорем. Компилятор и статические анализаторы

Формальные теории благодаря своей строгости позволяют автоматизировать процесы рассуждений. И при проверке различных утверждений о программах используются автоматизированные средства. Эти инструменты возможны как для сильных теорий, так и для проверки типов.

Системы автоматического доказательства теорем появились очень давно и начали использоваться в математике для проверки доказательств, проведённых ранее вручную. Когда появились формальные модели вычислений, алгоритмы доказательств стали применяться и для проверки программ. Алгоритмы доказательств в программировании используются не только в собственно системах доказательств математических теорем, но и в любых инструментах, где нужны автоматические рассуждения. В первую очередь это компиляторы и статические анализаторы, плагины автодополнения в IDE, системы автоматического рефакторинга.

Компилятору в первую очередь нужно проверить, что программа пригодна для трансляции в другое представление (машинный код). Для этого может использоваться в том числе и информация о типах. Информация о типах влияет на расположение объектов в памяти и регистрах процессора, на использование определённых инструкций и на выполнение оптимизирующих преобразований. Часть информации о типах служит лишь для проверки исходного кода и не играет роли на этапе генерации машинного кода. Но, тем не менее, эти проверки тоже выполняются компилятором. Поэтому компилятор можно рассматривать не только как средство сборки программ, но и средство проверки программы на типобезопасность, как статический анализатор.

> "Компилятор - ваш лучший друг. Возможно, единственный"

Однако, каждый раз выполнять сложные проверки при сборке программы дорого по времени, поэтому такие проверки возлагаются на отдельные инструменты статического анализа, работающие независимо от компилятора.

Средства статического анализа кода на основе системы типов также внедрены в IDE и средства автоматического рефакторинга. IDE может на лету проверять изменения в коде и подсвечивать ошибки. При этом используются ровно те же сведения о типах, что и в компиляторе. Для некоторых языков и компиляторов возможно использование средств самого компилятора для анализа кода. Например, компилятор CLang может использоваться не только как компилятор, но и для создания и поддерживания актуальной модели C++ кода в IDE, подсказывая заранее все возможные ошибки компиляции и предупреждения.

### Базовый язык и трансляция. Абстрактная модель кода

При рассмотрении системы типов определённого языка программирования обычно берётся за основу упрощённая версия этого языка. Это подмножество языка, очищенное от синтактического сахара и приведённое к каноническому виду, удобному для анализа. [Синтаксический сахар](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80) представляет собой синтаксические конструкции, которые не вносят серьёзных изменений в модель исполнения, не влияют на семантику языка, а служат лишь для удобства написания кода и улучшения восприятия человеком.

В качестве базового языка также можно рассматривать не подмножество оригинального языка, а промежуточное представление на другом языке или в байткоде, которое удобнее анализировать автоматически. Все компиляторы и статические анализаторы работают именно с упрощённой _моделью кода_, выраженной в _абстрактном синтаксисе_, не зависящем от _конкретного синтаксиса_. Абстрактная модель кода ближе к математической модели вычислений, взятой за основу для определения семантики языка.

### Моделирования вычислительных процессов и парадигмы программирования. Лямбда-исчисление

Есть несколько формализмов для моделирования вычислений. Они соответствуют парадигмам программирования и используются в качестве основы для описания семантики языков программирования. В них выражаются самые фундаментальные идеи, к которым затем добавляются другие элементы семантики языка.

В качестве примеров можно перечислить следующие модели вычислений:

* [Лямбда-исчисление](https://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5) и [комбинаторная логика](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0), а также [категориальная абстрактная машина](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%B0).
* [Конечные автоматы](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82), в том числе машина Тьюринга, сети Петри и другие.
* [Исчисление взаимодействующих процессов](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B8%D1%85_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC) и схожие с ним Пи-исчисление и модель акторов.
* [Нормальные алгоритмы Маркова](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC).
* Системы [логического программирования](https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

Наиболее интересными являются лямбда-исчисление и конечные автоматы. Исчисление взаимодействующих процессов предназначено для моделирования параллельных и асинхронных вычислений. Остальные модели вычислений менее популярны и рассматриваются как более специализированные. Лямбда-исчисление соответствует парадигме функционального программирования, а автоматные модели - последовательным императивным вычислениям.

Лямбда-исчисление несёт с собой такие фундаментальные понятия как _применение_ функции к аргументам, _абстрагирование_ путём выделения именованных переменных и _лексическая область видимости_ переменных. Код "программы", называемый лямбда-термом, представляет собой формулу из символов имён переменных, скобок, оператора абстрагоривания и оператора применения:

* Символы именования переменных (a, b, c, ... i, j, k, ... x, y, z),
* Скобки "(" и ")",
* Оператор абстракции `\` ("лямбда") в виде `\x.M`, где x - символ переменной, M - некоторый лямбда-терм,
* Оператор аппликации (применения) в виде `MN`, где терм M применяется к терму N

Оператор абстракции напоминает объявление локальной переменной или формального параметра функции. Оператор аппликации соответствует "вызову" терма как функции с передачей ему аргумента. Таким образом, термы можно представить как функции с одним аргументом, где в качестве аргумента могут быть другие термы.

Между термами вводятся две операции:

* Альфа-конверсия - переименование переменной. Например, в `\x.M` при переименовании x на у получится терм `\y.N`, где N - это терм M, где все вхождения x заменены на y.
* Бетта-редукция - подстановка аргумента. Например, результатом бетта-редукции терма `(\a.M)N` будет терм, полученный из терма M заменой всех вхождений a на N.

Предполагается, что в подтермах одного терма в операторах абстракции используются разные имена для переменных. Переменные, введённые после символа \ не должны повторяться, чтобы не вызывать коллизий имён. Однако, можно разрешить повторное использование имён переменных в пределах терма, если усложнить правила альфа-конверсии и бетта-редукции. Вместо того, чтобы выполнять подстановку всех вхождений имени, заменяются только те вхождения, которые действительно соответствуют этой переменной. Если внутри терма, в котором объявлена паременная, будет поддерм, объявляющий переменную с тем же именем, то это будет другая переменная. Например, есть терм:

    \x.(... x ... \x.( ... x ... ) ... x ... )

где многоточиями показаны места, которые не содержат x и нас не интересуют.

Если выполнить его применение к другому терму, то заменятся не все вхождения x:

    (\x.(... x ... \x.( ... x ... ) ... x ... )) M` --> `(... M ... \x.( ... x ... ) ... M ... )

Потому что внутренний подтерм \x.( ... x ... ) объявляет другую переменную x и скрывает объявление внешней переменной x.

Вхождение переменной в терм является _связанным_, если ему соответствует объявление с помощью оператора абстракции. Иначе переменная называется _свободной_. Например, в терме

    \x.(y \z.(xyz))

переменные x и z - связанные, а переменная y свободная. Её можно связать, добавив внешний оператор абстракции:

    \y.(\x.(y \z.(xyz)))

Термы, в которых все переменные связанные, называются _комбинаторами_. Именно комбинаторы используются для моделирования значений и вычислений в программе. Термы со свободными переменными являются лишь фрагментами кода, вырванными из контекста.

_Вычислением_ в лямбда-исчислении является пошаговый процесс применения операции бетта-редукции к терму. Бетта-редукция представляет собой по сути раскрытие скобок и подстановку значений вместо переменных. Она называется редукцией, потому что термы после преобразования в конце концов обычно становятся меньше. В конце процесса "вычисления", когда нельзя будет нигде применить бетта-редукцию, результирующий терм считается результатом выполнения программы.

Два терма называются эквивалентными, если они с точностью до альфа-конверсии в ходе вычисления могут быть редуцированы к одному и тому же результирующему лямбда-терму. Результирующий терм называется _нормальной формой_ терма. В теории лямбда-исчисления доказывается, что если процесс вычисления конечен и у терма существует нормальная форма, то она для этого терма _единственная_. Не важно, в каком порядке и к каким подтермам была применена бетта-редукция. Если процесс вычисления терма остановится, то он завершится на одной и той же нормальной форме.

Процесс вычисления терма может зациклиться. То есть, можно найти такую последовательность бетта-редукций терма, которая будет бесконечной. Существуют термы, которые не имеют нормальной формы, и их вычисление будет бесконечно. Самый простой пример:

    (\x.(x x))(\x.(x x))

После первого шага бетта-редукции будет получен тот же самый терм. Такой терм соответствует вечному циклу.

В чистом безтиповом лямбда-исчислении существуют только термы (комбинаторы), состоящие из переменных с применением скобок и операторов абстракции. Примеры самых простых термов:

    \x.x
    \x.(\y.x)
    \x.(\y.y)
    \x.(\y.xy)
    \x.(\y.yx)
    \x.(\y.(\z.xyz))
    ...
    и т.д.

Некоторые из этих термов можно считать представлением натуральных чисел, другие можно считать логическими значениями. Для них можно определить соответствующие операторы if, while, логические и арифметические операции. В теории алгоритмов доказывается, что любой алгоритм можно записать в виде лямбда-терма.

На практике при определении семантики языка программирования пользоваться чистым лямбда-исчислением не удобно. Поэтому лямбда исчисление обычно расширяется другими специальными синтаксическими конструкциями и значениями. Например, явно полагается использования цисел и логических значений, определяются операции над ними. А также, добавляются новые синтаксические конструкции, которые ближе подходят для понимания человеком. Например, добавляется оператор объявления локальной переменной:

    (let x = M; N)

где M и N - некоторые термы. Этот терм эквивалентен следующему терму:

    (\x.N)M

Аналогично определяются синтаксические конструкции для if-else и while с использованием соответствующих термов.

Существуют термы для создания рекурсивной функции и циклических вычислений. Это так называемые [комбинаторы неподвижной точки](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80_%D0%BD%D0%B5%D0%BF%D0%BE%D0%B4%D0%B2%D0%B8%D0%B6%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BA%D0%B8). Одним из примеров является Y-комбинатор:

    \f.(\x.f(x x))(\x.f(x x))

Однако, удобнее будет сразу определить специальный синтаксис letrec для рекурсивных объявлений, выразив его через комбинатор неподвижной точки при необходимости.

Итак, лямбда-исчисление, расширенное элементарными типами и специальными синтаксическими конструкциями, может служить основой для определения семантики языков программирования со сложными системами типов.

За более подробным описанием лямбда-исчисления и всего, что с ним связано, можно обратиться к книге Баренгдегт "Лямбда-исчисление". В этой книге подробно рассказывается про лямбда-термы, операции над ними, доказательства многих свойств и теорем, лямбда-теории, связь с комбинаторной логикой, специальные виды комбинаторов, деревья Бёма и топологии на них.

## Системы типов

После трансляции языка программирования в представление, близкое к расширенному лямбда-исчислению, можно выполнять проверку типов выражений в соответствии с системой типов. Система типов определяется в виде _правил типизации_, которые показывают, как на основе одних утверждений типизации доказывать другие. Система проверки типов (type checker) проводит доказательства, используя алгоритм _вывода типов_.

### Обзор систем типов по уровню гибкости

Далее будут очень поверхностно рассмотрены системы типов различного уровня сложности без каки-либо строгих определений и доказательств. Подробное рассмотрение всех систем типов можно найти в книге Пирса "Типы в языках программирования".

Самая простая система типов основана на __просто типизированном__ лямбда-исчислении. В синтаксис лямбда-исчисления добавляются _литералы_ значений (константы), которые однозначно можно отнести к тому или иному типу. Все значения разделяются на непересекающиеся множества, соответствующие простым типам. Например, вводятся следующие типы значений:

* Целочисленные значения (0, 1, 2, 3, 4, ...), соответствующие типу Int,
* Числа с плавающей точкой (0.5, 1.2, ...), соответствующие типу Float,
* Логические значения (true, false), соответствующие типу Bool.
* Строковые значения ("asdf", "qwerty", ""), сответствующие типу String.

Причём, целое число типа Float не считается принадлежащим типу Int, и наоборот.

Для утверждения типизации будет использован следующий синтаксис:

    выражение : тип

Например, можно привести следующие истинные утверждения типизации: `0 : Int`, `1 : Int`, `2 : Int`, `0.0 : Float`, `0.5 : Float`, `5.2 : Float`, `true : Bool`, `false : Bool`, `"qwerty" : String`.

Эта же запись может использоваться как часть синтаксиса рассматриваемого базового языка, чтобы добавлять дополнительное утверждение типизации в коде. Эти утверждения тоже будут учитываться в процессе вывода типов. Запись утверждения о типе выражения в коде называется _аннотацией типа_.

Для элементарных простых типов вводятся соответствующие правила типизации, согласно которым литеральное (константное) выражение, обозначающее элементарное значение, будет иметь соответствующий тип, совпадающий с типом этого значения.

Элементарные типы можно расширить перечислениями. Тип Bool можно считать примером перечисления, состоящего из двух значений: true и false. Можно ввести любые другие типы перечислений, представляющих собой произвольные множества объектов любой предметной области. Например, тип дней недели WeekDay состоит из множества значений Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday. Каждое значение перечисления является атомарным (не структурированным) и служит лишь для проверки на совпадение с другими значениями перечисления. Никакие другие операции для перечислений, кроме проверки на равенство, не встроены в язык, не учитываются при типизации.

Кроме _элементарных_ типов в язык можно добавить следующие _сложные_ типы:

* Кортежи - упорядоченные последовательности фиксированной длины, обозначаемые значениями через запятую в скобках `(элемент1, элемент2, элемент3)`,
* Структуры - неупорядоченные множества именованных элементов (полей), обозначаемые в виде `{имя1=значение1, имя2=значение2, ...}`.

Например, кортеж `(1, 0.5, false) : (Int, Float, Bool)`, а структура `{x=5, y=0.4, z=false} : {x=Int, y=Float, z=Bool}`, причём, имена x, y и z являются частью структурного типа, и структура с другим набором полей будет считаться другим типом.

Сложные (combound) типы могут состоять из элементарных и быть вложенными, например:

* Кортежи кортежей, например `((5, 5), true, (6.7, true), 0.01) : ((Int, Int), Bool, (Float, Bool), Float)`,
* Структуры с вложенными структурами, например, `{a={x=5, y=10}, b={z=0.5, d=false}, c=0} : {a={x=Int, y=Int}, b={z=Float, d=Bool}, c=Int}`,
* Кортежы из структур, например `({x=5, y=10}, true, {z=0.5, d=false}, 0.01) : ({x=Int, y=Int}, Bool, {z=Float, d=Bool}, Float)`,
* Структуры с кортежами, например, `{a=(5, 5), b=(6.7, true), c=0} : {a=(Int, Int), b=(Float, Bool)}, c=Int}`,

Кроме значений в лямбда-исчислении существуют функциональные выражения, имеющие так называемые стрелочные типы. Например, если `N : U`, a `(\x.M)N : T`, то

    \x.M : U -> T

Запись `U -> T` - это и есть стрелочный тип. Это означает, что терм `\x.M` при применении к аргументами типа U выполняет преобразование в значения типа T. В этом случае переменной x и всем её вхождениям в терме M можно приписать тип U. Функциональные термы (имеющие стрелочный тип) могут принимать на вход другие функции и возвращать функции. Например, тип `(A -> B) -> C` - это тип функции, применяемой к другой функции, требующей на входе тип A и возвращающей тип B, и результат применения функции будет иметь тип C. В качестве A, B и C могут быть любые другие типы: элементарные типы, кортежи, структуры, стрелочные типы.

Язык можно расширить встроенными операциями, имеющими стрелочные типы. Например:

* `+ : (Int, Int) -> Int`,
* `- : (Int, Int) -> Int`,
* `* : (Int, Int) -> Int`,
* `/ : (Int, Int) -> Int`,
* `< : (Int, Int) -> Bool`,
* `> : (Int, Int) -> Bool`,
* `= : (Int, Int) -> Bool`,
* `!= : (Int, Int) -> Bool`,
* +, -, *, /, <, >, =, != аналогично для типа Float,
* `int(x) : Float -> Int` (преобразователь из Float в Int),
* `float(x) : Int -> Float` (преобразователь из Int в Float).

Все синтаксические конструкции +, -, *, /, <, >, =, != требуют отдельных правил типизации. Аналогично вводятся операции AND, OR, NOT для типа Bool.

Для удобства сложным типам можно давать имена или псевдонимы. Например:

* `type FloatPair = (Float, Float)`,
* `type IntPair = (Int, Int)`,
* `type Point = { x: Float, y: Float }`,
* `type Milliseconds = Int`,

а также, операци их создания:

* `FloatPair(0.1, 0.2)`,
* `IntPair(1, 4)`,
* `Point{ x: 8.346, y: -3.547 }`,
* `Milliseconds(5)`.

Ошибкой согласования типов в простой типизации является несовпадение типов, доказанных разными путями для одного выражения. Каждое выражение должно иметь в точности один тип, каким бы путём он не был доказан из предпосылок по правилам вывода. Предпосылками являются аннотации типов при объявлении переменных и параметров функций, а также сведения о типе литеральных выражений - чисел, логических значений, значений перечислений.

Простая типизация достаточна для выражения многих идей в языках программирования. Подмножества таких языков как C и Pascal можно описать одной лишь простой типизацией. Если считать, что все преобразования между числовыми и логическими типами должны выполняться явно, исключить арифметику указателей и небезопасные приведения типов, то можно считать, что у C и Pascal простая типизация. Однако, на практике в этих языках часто встречаются случаи, когда информация о типе теряется, и программист сам берёт на себя управление типами выражений, добавляя явно аннотации типов в коде для небезопасного приведения типов. В этом случае программа не считается типобезопасной, просто компилятору даны инструкции игнорировать ошибки типизации в конкретных местах.

В практике программирования существует проблема повторного использования кода. Иногда требуется использовать один и тот же код для разных типов данных. Эти типы могут быть достаточно похожи между собой, чтобы можно было использовать с ними один и тот же код. Решение этой проблемы известно как _полиморфизм_, который в самом простом случае присутствует при добавлении подтипов в систему типов языка.

Система типов с __подтипами__ определяет между типами отношение подтипов, согласно которому если выражению можно приписать некоторый тип, то это выражение может принимать значения, принадлежащие подтипам этого типа. Отношение подтипов можно связать с отношением вложенности множеств, соответствующих значениям этих типов.

Отношение подтипов чем-то напонимает наследование классов и интерфейсов в ООП-языках. Если переменная имеет тип базового класса или интерфейса, то она может принимать значения любого производного класса, наследующего базовый класс или реализующего интерфейс. Классы являются подтипами своих базовых классов и реализованных интерфейсов.

В языках со _структурной_ типизацией типы-структуры сами по себе не имеют имени и определяются лишь своим содержимым. Два структурных типа с одинаковым набором полей и одинаковыми типами значений этих полей представляют собой один и тот же тип. При _номинальной_ системе типов каждый именованный тип отличается от всех остальных типов. Например, типы Point{x: Int, y: Int} и Size{x:Int, y:Int} в номинальной системетипов считаются разными структурами, хотя их поля совпадают.

В структурной типизации при определении отношения подтипов считается, что одна структура является подтипом другой структуры, если она содержит тот же набор полей с теми же типами, что и у структуры-надтипа, и, возможно, некоторые другие. Например, тип `{x: Int, y: Int, z: Int}` является подтипом типа `{x: Int, y: Int}`, а также, типов `{y: Int, z: Int}`, `{y: Int, z: Int}`, `{x: Int}`, `{y: Int}` и `{z: Int}`. В номинальной системе типов структурные типы являются подтипами друг друга только тогда, когда это явно декларируется в коде, например, в виде наследования именованных структур.

В системе типов с подтипами вводятся операции создания новых типов на основе существующих: _сумма_ типов и _произведение_ типов. Они соответствуют операциям объединения и пересечения множеств:

* Сумма типов: `T1 | T2 | T3`,
* Произведение типов: `T1 & T2 & T3`.

Утверждение `e: T1 | T2 | T3` означает, что выражение `е` может принимать значение любого из типов T1, T2 и T3. В этом случае типы T1, T2 и T3 будут подтипами типа `T1 | T2 | T3`. Также типы `T1 | T2`, `T2 | T3`, `T1 | T3` являются подтипами типа `T1 | T2 | T3`.

Операция [суммы](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF-%D1%81%D1%83%D0%BC%D0%BC%D0%B0) типов является коммутативной. Записи `T1 | T2` и `T2 | T1` означают один и тот же тип.

Для проверки, к какому же конкретному типу принадлежит значение типа суммы, в язык вводится специальная операция-предикат, проверяющая принадлежность значения заданному типу. Например, выражение

    e is T2

будет возвращать true _во время исполнения_, если `e` в момомент вычисления примет значение, принадлежащее типу T2, хотя для выражения `e` может быть доказано лишь то, что оно имеет надтип типа T2 (например, `T1 | T2 | T3`). Такая проверка типа в runtime требудет должной реализации среде исполнения языка. Для хранения значения переменной `e` может потребоваться дополнительный признак типа, обозначающий тип текущего значения.

Особым случаем суммы типов является _размеченное объединение_, которое представляет собой гибрид суммы типов и перечисления:

    Tag1 T1 | Tag2 T2 | Tag3 T3
или
    enum {Tag1 T1, Tag2 T2, Tag3 T3}

Здесь Tag1, Tag2, Tag3 - элементы перечисления, представляющие собой _тэги_ (метки), а T1, T2, T3 - типы содержимого значений, привязанных к тегам. В размеченном объединении гарантируются, что значение выражения будет принадлежать только одному элементу из объединения. Например, тип

    type MayBeInt = Ok Int | Error Int
или
    type MayBeInt = enum {Ok Int, Error Int}

означает, что выражение может принять значение либо Ok с некоторым целым числом-результатом, либо Error с целым числом кода ошибки.

[Типы-произведения](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5) определить сложнее, так как в разных языках могут присутствовать разные их воплощения. Суть в том, что, например, значение типа `T1 & T2 & T3` должно уметь "вести себя" так же, как значения типа T1 или T2, или T3. В качестве простых знакомых примеров можно предложить _множественное наследование_ в C++ или наследование интерфейсов в C# и Java, использование trait-ов в Scala и Rust. Однако, эти примеры не совсем точно соответствуют определению произведения типов. Не всякие типы можно соединить в произведение. Значение `e: T1 & T2 & T3` должно быть реализовано так, чтобы его можно было передать в код, где требуется тип T1 или T2, или T3 (или `T1 & T2`, или `T2 & T3`, или `T1 & T3`). Для этого значение `e` должно содержать в себе все реализации значений типов T1, T2 и T3, и уметь в любой момент "включать" нужную из них.

Все типы системы типов с подтипами можно организовать в виде [решётки](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D1%91%D1%82%D0%BA%D0%B0_(%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0)) типов. На вершине решётки будет специальный тип Any. Все типы являются подтипами типа Any. Утверждение `e: Any` означает, что выражение e может принимать какое-угодно значение. Аннотация типа Any в коде означают, что программиста не интересует тип выражения в данный момент, код готов работать со значениями любого типа, которые примет данное выражение. На противоположном конце решётки будет тип Nothing, который является подтипом любого другого типа и означает ошибочное вычисление. Ни одно значение не принадлежит типу Nothing Если в программе появится значение типа Nothing, то оно может распространяться дальше и дальше по программе и выйдет наружу как результат. Оно чем-то напоминает NaN (Not a Number) в числах с плавающей точкой.

Можно придумать типы, состоящие только из одного значения. Например, тип One, единственным значением которого будет число 1. Аналогично можно определить типы Two и Three. Они будут подтипами типа `One | Two | Three`, которому тоже можно дать осмысленное имя. Также, например, можно определить тип положительных целых чисел, который будет подтипом типа Int, или отрицательных. Аналогично можно сделать и со строковыми типами, и с логическим. Такие типы выражений будут представлять собой более сильные высказывания о значениях выражений. И при правильном определении всех правил типизации для таких типов алгоритм вывода типов может применяться как алгоритм доказательства утверждений, выраженных в типах. Это наглядно показывает, что типы могут выражать не только способ хранения значений в памяти, но и дополнительные ограничения на эти значения.

До этого момента предполагалось, что сложные (compound) типы, основанные на более простых, не могут включать сами себя в качестве своих составных частей. Например, нельзя определить структуру:

    type IntNode = {value: Int, next: IntNode}

Такие типы называются __рекурсивными__. Добавление рекурсивных типов в систему типов даёт ещё больший уровень гибкости и выразительности. Приведённый пример рекурсивного типа IntNode не совсем корректен, так как не существует ни одного значения, принадлежащего этому типу. Если бы такое значение существовало, оно было бы бесконечно длинной цепочкой вложенных структур. Корректный пример, определяющий тип линейного связанного списка, выглядел бы так:

    type IntList = EmptyList | Node Int IntList

Это размеченное объединение, определяющее тип IntList как цепочку значений с тэгом Node, содержащих "голову" списка типа Int и "хвост", являющийся списком того же типа. Причём, в качестве хвоста может быть метка EmptyList. Ещё один пример, бинарное дерево:

    type IntTree = Leaf | Node {value:Int, left: IntTreem, right: IntTree}

Бинарное дерево состоит из узлов-структур, помеченных тэгом Node, которые содержат значение value и два поддерева left и right, являющиеся тоже деревьями типа IntTree. Тег Leaf означает лист дерева.

Не во всех языках присутствуют рекурсивные типы в таком виде. Рекурсивные типы запрещены в таких языках как C/C++ и Rust, где структурные типы чётко определяют расположение значений в памяти. В C/C++ нельзя описать структуру, содержащую поле её же типа. Но можно описывать структуры, содержащие указатели на самих себя. Например:

    struct IntTree {
       int value;
       IntTree *left;
       IntTree *right;
    };

В Rust вместо указателей могут использоваться различные версии "умных" указателей. В языках Java и C# классы сразу видны везде в своём пространстве имён (пакете) и автоматически считаются Nullable. Поэтому с помощью классов можно объявлять рекурсивные типы.

При описании и использовании compound типов возникает потребность в нескольних похожих типах, различающихся лишь типом какого-то внутреннего элемента. Например, потребуется объявить отдельный тип для целочисленных списков, отдельный тип для строковых списков, отдельный для логических и т.д. И так же придётся сделать с фрагментами кода, которые их используют. Система типов с подтипами даёт лишь самый простой способ [полиморфизма](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) типов. А хотелось бы и для таких случаев достичь большей степени повторного использования кода. Решением будет дальнейшее усложнение полиморфизма типов и добавление шаблонных типов и [типов-параметров](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC). Шаблонные типы во многих языках называются __generics__, и представляют собой "операции" над типами-аргументами. Это своего рода типовые функции, которые принимают на вход типовые аргументы и возвращают типы-результаты.

Вот так мог бы выглядеть обобщённый тип линейного списка в системе типов с типами-параметрами:

    type List<T> = EmptyList | Node{value: T, next: List<T>}

`List<T>` - это шаблонный тип, который при подстановке вместо T конкретных типов будет возвращать конкретные типы списков. Например, `List<Int>`, `List<Bool>`, `List<List<{x: Int, y: Int}>>`.

Так как шаблонные типы напоминают типы над функциями, в отношении типов можно применить то же самое лямбда исчисление и даже ввести похожее обозначение. Например,

    type List = \T.(EmptyList | Node{value: T, next: List})

Лямбда-исчисление с полиморфными типами называется [System F](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_F).

Можно пойти дальше и типизировать такое "лямбда-исчисление типов", добавляя ограничения на типы-параметры. В этом случае к типам-параметрам применяется [ограниченная квантификация](https://en.wikipedia.org/wiki/Bounded_quantification). Такие ограничения будут являться "типами типов" и в разных языках называются по разному. В Haskell они называются классами типов, в C#, Java, Rust в качестве классов типов могут выступать обычные интерфейсы и абстрактные классы, в C++ это ограничения на типы параметров шаблонов, а также [концепты](http://en.cppreference.com/w/cpp/language/constraints). 

Самые мощные системы типов приближаются к своей гибкости и универсальности к логиге Хоара. При проверке типов в таких системах потребуется проводить сложные вычисления с типами. Самый простой пример - [зависимые типы](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF). На вершине всех систем типов по сложности стоит __исчисление конструкций__, являющееся предметом рассмотрения [конструктивной математики](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0).

### Вывод типов

Алгоритм [вывода типов](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2) представляет собой решение системы уравнений с типовыми переменными. Известными значениями считаются типы литеральных значений и аннотации типов. Остальные типы выражений считаются неизвестными и требуют определения.

Например, есть следующий фрагмент кода:

    let a = 1
    let b = 2 + a
    let c = b > a

Известными утверждениями здесь будут тип числа `1 : Int`, тип операции `+ : <T : Number> (T, T) -> T` (для любых T, являющихся подтипом Number) и тип операции `> : <T : Number> (T, T) -> Bool`. Также известны правила типизации для оператора let и присваивания. Требуется определить тип переменных a, b, c и выражений `2 + a` и `b > a`.

Алгоритм вывода типов основан на алгоритме [унификации](https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B9_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9_%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D1%8B). Там, где согласно правилам типизации два неизвестных типа должны совпадать, создаются связи неизвестных значений с известными. Например, для выражения `2 + a` известно лишь то, что операци + передаются два аргумента `2 : Int` и `a` пока неизвестного типа. Известен тип операции `+`, которые сопоставляется с типами аргументов. При сопоставлении типа аргумента Int с типом `<T : Number> (T, T) -> T` образуется связь `T=Int`, операции + приписывается тип `(Int, Int) -> Int`, после чего переменной a можно приписать тип Int. Результатом выражения тоже будет Int. В первой строке фрагмента переменной a тоже приписывается тип Int. Из второй строки следует, что переменная b имеет тип. В третьей строке операция `<` на основе типов a и b `(Int, Int) -> Bool` (`T=Int`), и переменная c имеет тип Bool.

Зто был очень простой пример, в котором нет ветвлений, циклов, функций, и типы очень простые.

В большинстве традиционных языков тип переменных и параметров функций должен быть указан при объявлении. Также тип возвращаемого значения функции должен быть указан. Но даже в таких языках (Java, C# до 3.0, С++ до C++11) алгоритм вывода типов присутствует и применяется, например, при определении типов промежуточных выражений.

Не для всех систем типов задача вывода типов алгоритмически разрешима. Поэтому на практике языки не имеют слишком мощной системы типов, ограничиваясь только System F с ограниченной квантификацией, при которой применим алгоритм [Хиндли-Милнера](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2).

